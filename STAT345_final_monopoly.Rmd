---
title: "STAT 345 Final Project - Real Estate"
author: "STAT 345"
output: html_document
---

Expected Submission: You will generate a well-written R Markdown report that addresses the following prompts. This R Markdown report should source your analysis code and only display top-level, abstracted code _if/when appropriate_. Choices made during the analysis project should be described and justified in the report. You will present on your results during the final exam period for the semester. The written report (knitted file), presentation file, and your analysis code should be submitted to D2L by Tuesday, May 14 at 12:15pm. 

**General advice:** Get started early. If you wait to the last minute, it will not go well. For this project, you may find yourself spending a reasonable amount of time _searching_ for help.

1. _Rules!_ Monopoly has several rules related to movement around the game board. Movement is affected by standard dice rolls, special conditions for some dice rolls, and game cards. Find and summarize these rules. 

2. _Let's Get Moving_ Build a system that allows for up to 4 players to move around the game board. As a first attempt, focus on standard dice rolls, ignoring additional rules related to rolling doubles, jail, or special cards. Which properties are landed on most frequently? Create a visualization for this!

3. _Double Down_ Improve your system to incorporate going to jail, including the doubles-rolling condition. Which properties are landed on most frequently now? Has this changed dramatically from the previous system (that didn't account for jail)? Again, visualize this!

4. _Take a Chance_ Incorporate the movement cards into your system. You can ignore the effects of non-movement cards, but not their existence! Which properties are landed on most frequently now? Has this changed dramatically from the previous system (that didn't account for Chance)? Again, visualize this!

5. _Play a Game_ Extend your system to allow for up to 4 players to "play" the game. You may choose a reasonable starting board and player money level (so, you don't have to buy properties). Include payments between players, payments to the bank, and payments from the bank (there are several cards that will effect these that you should account for). You do not need to consider mortgaging properties (so a player loses when their liquid cash has run out). How long do games typically last given your starting board and money level? How does this change if money paid to the bank is placed in "Free Parking" and awarded to players landing on that space?


```{r}
#prop <- read.csv("Properties.csv")
prop <- read.csv("Game_Board_Spaces_Git.csv")
equip <- read.csv("General Equipment CSV.csv")
players <- read.csv("Players Dataset CSV.csv")
railroads <- read.csv("Railroads Dataset CSV.csv")
deeds <- read.csv("Title Deeds Dataset CSV.csv")
util <- read.csv("Utilities Dataset CSV.csv")
action_cards <- read.csv("Action_Cards_Git.csv")

#make dataframes more tidy:
library(tidyverse)
deeds <- deeds %>% select(-"Identifier")
util <- util %>% select("Utility.Company", "Purchase.Price", "Rent.with.1.Utility", "Rent.with.2.Utility", "Mortgage.Value")
action_cards <- action_cards %>% select(-Money)

#install.packages("devtools")
#devtools::install_github("mkuhn/dict")
library(dict)

#players <- c(1,2,3,4)

position <- dict()
position[1] <- 1
position[2] <- 1
position[3] <- 1
position[4] <- 1

spaces <- dict()
locations <- c(prop$Properties)
i <- 0
while(i < 41){
  spaces[i] <- locations[i]
  i <- i + 1
}

```


#creating and initiating board:
```{r}
board <- vector(mode = "list", length = 40)

#sets each board space to count 0
for( i in 1:40){
  board[[i]] <- 0
}

names(board) <- prop$Properties
```

#counting amount of times a space is landed on:
```{r}
position[1] <- 1
num <- position[[1]]

simulation <- function(times){
  
  for(i in 1:times){
    position[1] <- roll_to_move_player(1)
    num <- position[[1]]
    board[[num]] <- board[[num]] + 1
  }
  board
}
```
#frequency simulation and graph
```{r}
library(tidyverse)

spot_frequency <- simulation(5000)

frequency_data <- as.data.frame(spot_frequency) 


frequency_data <- frequency_data %>% pivot_longer(1:40)

frequency_data

#keeps places in order from board
frequency_data$name <- factor(frequency_data$name, levels = frequency_data$name)

#frequency graph 
ggplot(frequency_data, aes(name, value)) + geom_col() + labs(title = "Space Frequency", x = "Space Number", y  = "Frequency") + theme(axis.text.x = element_text(angle = 90))

```

#heatmap simulation and graph
```{r}
library(tidyverse)

#spot_frequency <- simulation(5)
frequency_data = 0
for(i in 2:40){
  frequency_data[i] = 0
}
for(i in  1:1000){
  temp <- roll_to_move_player(1)
  position[[1]] <- temp
  frequency_data[temp] <- frequency_data[temp] + 1
}
monopoly_board_matrix <- matrix(data = c(frequency_data[21], frequency_data[22], frequency_data[23], frequency_data[24], frequency_data[25], frequency_data[26], frequency_data[27], frequency_data[28], frequency_data[29], frequency_data[30], frequency_data[31], frequency_data[20],0,0,0,0,0,0,0,0,0, frequency_data[32], 
frequency_data[19],0,0,0,0,0,0,0,0,0, frequency_data[33], 
frequency_data[18],0,0,0,0,0,0,0,0,0, frequency_data[34],
frequency_data[17],0,0,0,0,0,0,0,0,0, frequency_data[35], 
frequency_data[16],0,0,0,0,0,0,0,0,0, frequency_data[36], 
frequency_data[15],0,0,0,0,0,0,0,0,0, frequency_data[37],
frequency_data[14],0,0,0,0,0,0,0,0,0, frequency_data[38], 
frequency_data[13],0,0,0,0,0,0,0,0,0, frequency_data[39], 
frequency_data[12],0,0,0,0,0,0,0,0,0, frequency_data[40],
frequency_data[11], frequency_data[10], frequency_data[9], frequency_data[8], frequency_data[7], frequency_data[6], frequency_data[5], frequency_data[4], frequency_data[3], frequency_data[2], frequency_data[1]), nrow = 11, ncol = 11)
heatmap<-heatmap(x=monopoly_board_matrix, Colv = NA, Rowv = NA, scale = "none")
library(ggplot2)
#df = as.data.frame(frequency_data)
#ggplot(df,(aes(1:40,1))) + geom_tile(aes(fill = frequency_data))
```

```{r}
#more complex dice roll that factors in double rolls
 # dice_roll <- function(){
  
  #first dice roll 
 # dice <- sample(1:6, 2, replace = TRUE)
  
  #if you roll doubles, rolls again
  #if(dice[1] == dice[2]){
    
   # dice <- sample(1:6, 2, replace = TRUE)
    
    #if you roll doubles, rolls again
   # if(dice[1] == dice[2]){
    
     # dice <- sample(1:6, 2, replace = TRUE)
      
      #if you roll doubles, tells you to go to jail
     # if(dice[1] == dice[2]){
    
     # dice <- sample(1:6, 2, replace = TRUE)
      #print("Go to Jail")
    # }
    #}
  #}
  
  #prints the sum of your numbers (amount of spots you move) unless you go to jail
 # if(dice[1] != dice[2]){
  
   # sum(dice)
 #}
#}
```

#chance card: finding the neareset railraod
```{r}
#railroad_num <- c(6, 15, 25, 35)

#position[1] <- 40
#position[[1]]

#difference <- railroad_num - position[[1]]
#difference

#maxnegative <- function(x){
  #min(x)
#}
#minpositive <- function(x){
  #min(x[x > 0])
#}

#if (all(difference < 0)){
   #print("All values are non-negatives!")
  #distance <- maxnegative(difference)
  
#}else{
  #distance <- minpositive(difference)
#}

#distance

#next_railraod <- distance + position[[1]]

#position[1] <- next_railraod

#position[[1]]
```

#REFINED FUCNTIONS: (05-04-2021)
  #Updated all previous functions to work for the condition: "Go to Jail."
  #Fixed a bug in the moving() and moving_doubles() functions

#SECTION 01: MOVEMENT (05-04-2021)

#Various Roll Dice Functions:
```{r}

#All functions mimic rolling dice in a game of monopoly. roll_dice() is used for regular dice movement; force_doubles() and differing_dice() were used for testing. 

roll_dice <- function()
{
  dice <- sample(1:6, 2, replace = TRUE)
  return(dice)
}


force_doubles <- function()
{
  dice <- sample(1:1, 2, replace = TRUE)
  return(dice)
}


differing_dice <- function()
{
  dice <- sample(1:6, 2, replace = TRUE)
  
  while (dice[1] == dice[2]) 
  {
    dice <- sample(1:6, 2, replace = TRUE)
  }
  
  return(dice)
}

```

#Moving Before Relocation of Player:
```{r}
#1) moving() allows us to move a player from their starting position. We found that using only moving() creates an issue for movement, as the function does not "remember" the previous roll when adjusting movement.

action_locations <- which(spaces %in% c("Chance", "Community Chest"))

moving <- function(playerID, spaces_to_move)
{
  #Player's position on board + dice roll amount:
  position[[playerID]] <- position[[playerID]] + spaces_to_move
  user_place <- position[[playerID]]
  
  #Restarts Count after Passing GO:
  if(user_place >= 41)
  {
    user_place <- user_place - 40
  }
  
  if(user_place %in% action_locations)
  {
    pi <- playerID 
    user_place <- chance_or_community_chest(pi, user_place)
    
    if(user_place >= 41)
    {
      user_place <- user_place - 40
    }
  }
  
  else
  {
    print(paste0("Player", playerID, " moves ", spaces_to_move, " spaces and lands on: ", spaces[[user_place]]))
    #position[playerID] <- user_place
  }
    
  return(user_place)
}
```

#Moving After Relocation of Player:
```{r}
#2) moving_doubles() is used when multiple dice rolls (i.e. a relocation of a player) need(s) to be considered. This stores player's last location and moves the player from their last known location.

moving_doubles <- function(playerID, spaces_to_move, player_location)
{
  position[[playerID]] <- player_location
  position[[playerID]] <- position[[playerID]] + spaces_to_move
  user_place <- position[[playerID]]
  
  #print(user_place)
  
  #Restarts count after passing GO
  if(user_place >= 41)
  {
    user_place <- user_place - 40
  }
  
  if(user_place %in% action_locations)
  {
    pi <- playerID 
    user_place <- chance_or_community_chest(pi, user_place)
    
    if(user_place >= 41)
    {
      user_place <- user_place - 40
    }
  }
  
  else
  {
    print(paste0("Player", playerID, " moves ", spaces_to_move, " spaces and lands on: ", spaces[[user_place]]))
    #position[playerID] <- user_place
  }
    
  return(user_place)
}
```

#Jail Roll:
```{r}

jail_roll <- function(playerID, counter = 1, player_position = 11, type_of_roll = roll_dice())
{
  #position[[playerID]] <- player_position
  p <- player_position
  
  roll <- type_of_roll
  
  if(roll[1] == roll[2])
  {
    if(counter == 3)
    {
      print(paste0("Player", playerID, " rolls doubles for a third time!", " The sum of their roll is: ", totalDice))
      print(paste0("Player", playerID, " returns to Jail for rolling too many doubles."))
      #Go_to_Jail(playerID) #(Go_to_Jail implimented in following section)
    }
    
    else
    {
      totalDice <- sum(roll)
  
      if(counter == 1)
      {
        print(paste0("Player", playerID, " rolls doubles!", " The sum of their roll is: ", totalDice))
        new_position <- moving_doubles(playerID, totalDice, 11)
        player_position <- new_position
      }
      
      else
      {
        #print(roll)
        print(paste0("Player", playerID, " rolls doubles again!", " The sum of their roll is: ", totalDice))
        new_position <- moving_doubles(playerID, totalDice, p)
        player_position <- new_position
      }
      
      jail_roll(playerID, counter + 1, new_position)
    }
  }
  
  else
  {
    totalDice <- sum(roll)
    
    if(counter == 1)
    {
      print(paste0("Player", playerID, " rolls: ", totalDice))
    }
    
    else
    {
      print(paste0("Player", playerID, " rolls again and rolls: ", totalDice))
    }
    
    moving_doubles(playerID, totalDice, p)
  }
}
```

#Rolls for Movement:
```{r}
#The following function rolls the dice for movement purposes; there are a couple parts worth noting:
  #The roll_to_move_player function uses four functions: roll_dice, moving, moving_doubles, and chance_or_community_chest.
  #There are several cases to consider, but they are all designed to account for the count of the doubles and player location after each movement.
  #Minor movement error when "Going to Jail"; moves to correct space, but continues to move. 
    #Jail is working close to properly now.

roll_to_move_player <- function(playerID, counter = 0, player_position = 1, type_of_roll = roll_dice())
{
  p <- player_position
  
  roll <- type_of_roll
  
  if(roll[1] == roll[2])
  {
    if(counter == 2)
    {
      totalDice <- sum(roll)
      
      print(paste0("Player", playerID, " rolls doubles for a third time!", " The sum of their roll is: ", totalDice))
      print(paste0("Player", playerID, " is sent to Jail for rolling too many doubles."))
      In_Out_Jail(playerID)
    }
    
    else
    {
      totalDice <- sum(roll)
  
      if(counter == 0)
      {
        print(paste0("Player", playerID, " rolls doubles!", " The sum of their roll is: ", totalDice))
        new_position <- moving(playerID, totalDice)
        player_position <- new_position
      }
      
      else
      {
        #print(roll)
        print(paste0("Player", playerID, " rolls doubles again!", " The sum of their roll is: ", totalDice))
        new_position <- moving_doubles(playerID, totalDice, p)
        player_position <- new_position
      }
      
      roll_to_move_player(playerID, counter + 1, new_position)
    }
  }
  
  else
  {
    totalDice <- sum(roll)
    
    if(counter == 0)
    {
      print(paste0("Player", playerID, " rolls: ", totalDice))
      moving(playerID, totalDice)
    }
    
    else
    {
      print(paste0("Player", playerID, " rolls again and rolls: ", totalDice))
      moving_doubles(playerID, totalDice, p)
    }
  }
}

```

#Move Player 1 for Testing:
```{r}
position[1] <- roll_to_move_player(1)
position[1]
#spaces[[position[[1]]]]

#position[1] <- 1
```


#SECTION 02: JAIL FUNCTIONS: (05-04-2021)

#Check Player's Hand:
```{r}
Check_Hand <- function(player_identifier)
{
  players[player_identifier,]
}
```

#In Jail/Exiting Jail:
```{r}
#Currently trying to adjust the jail function to be implemented under the moving doubles function.  

In_Out_Jail <- function(player_identifer, counter = 0)
{
  position[player_identifer] <- 11
  
  if(counter == 0)
  {
    print(paste0("Player", player_identifer, " is now in jail."))
    In_Out_Jail(player_identifer, counter + 1)
  }
  
  else
  {
    hand <- Check_Hand(player_identifer)
    card <- hand %>% select(Get.Out.of.Jail.Free) 
    
    if(is.na(card) == FALSE)
    {
      players[player_identifer, ]$Get.Out.of.Jail.Free <- NA
      print(paste0("Player", player_identifer, " uses a 'Get Out of Jail Free Card.'"))
      jail_roll(player_identifer)
    }
    
    else
    {
      funds <- hand %>% select(Bank)
      
      if(funds >= 500)
      {
        players[player_identifer, ]$Bank <- players[player_identifer, ]$Bank - 50
        print(paste0("Player", player_identifer, " pays $50 to exit jail."))
        jail_roll(player_identifer)
      }
      
      else
      {
        roll <- roll_dice()
        
        if(roll[1] == roll[2])
        { 
          print(paste0("Player", player_identifer, " rolls doubles to exit jail."))
          jail_roll(player_identifer)
        }
        
        else
        {
          if(counter < 2)
          {
            print(paste0("Player", player_identifer, " remains in jail."))
            In_Out_Jail(player_identifer, counter + 1)
          }
          
          else
          {
            funds <- hand %>% select(Bank)
      
            if(funds >= 50)
            {
              funds[[1]] <- funds[[1]] - 50
              
              print(paste0("Player", player_identifer, " pays $50 to exit jail."))
              jail_roll(player_identifer)
            }
            
            else
            {
              print(paste0("Player", player_identifer, " is bankrupted."))
              #remove player from player dataset?
            }
          }
        }
      }
    }
  }
  
  #return(exit_roll)
  #invisible(players)
}
```


#SECTION 03: ACTION CARDS (05-04-2021)

#Action Card Movement:
```{r}

#Helper Functions for chance_or_community_chest()

#a) Distance Functions:

maxnegative <- function(x)
{
  min(x)
}

minpositive <- function(x)
{
  min(x[x > 0])
}

#b) Movement Based on Action Card Description: 

action_card_movement <- function(playerID, player_location, card_text)
{
  rail_or_util_spaces <- c()
  
  if(card_text == "Nearest Railroad")
  {
    rail_or_util_spaces <- c(6, 16, 26, 36)
  }
  
  if(card_text == "Nearest Utility")
  {
    rail_or_util_spaces <- c(13, 29)
  }
  
  if(card_text == "-3")
  {
    minus_3 <- player_location - 3
    
    if(minus_3 <= 0)
    {
      minus_3 <- minus_3 + 40
    }
    
    print(paste0("Player", playerID, " moves back 3 spaces and lands on ", spaces[[minus_3]]))
    
    return(minus_3)
  }
  
  if(card_text == "Jail / Just Visiting")
  {
    location_after_exiting_jail <- In_Out_Jail(playerID)
    return(location_after_exiting_jail)
  }
  
  if((card_text != "Nearest Utility") && (card_text != "Nearest Railroad") && (card_text != "-3") && (card_text != "Jail / Just Visiting"))
  {
    print("You shouldn't be in here!")
    return(player_location)
  }
  
  #player_position <- position[[playerID]]
  
  difference <- rail_or_util_spaces - player_location
  
  if (all(difference < 0))
  {
    #print("All values are negatives!")
    distance <- maxnegative(difference)
  }
  
  else
  {
    distance <- minpositive(difference)
  }
  
  #print(distance)
  
  nearest <- distance + player_location

  print(paste0("Player", playerID, " moves to ", spaces[[nearest]]))

  return(nearest)
}
```


#Landing on Chance:
```{r} 

chance_or_community_chest <- function(playerID, player_position)
{
  chance_locations <- which(spaces %in% "Chance")
  community_chest_locations <- which(spaces %in% "Community Chest")
  
  #added:, "Jail / Just Visiting"
  problem_cards <- c("Nearest Utility", "Nearest Railroad", "-3", "Jail / Just Visiting")
  
  if(player_position %in% chance_locations)
  {
    chance_cards <- action_cards %>% filter(Card.Type %in% "Chance")
    rand_num <- sample(1:15, 1, replace = TRUE)
    specific_action <- chance_cards[rand_num,]
    print(paste0("Player", playerID, " lands on Chance and draws a Chance card."))
    print(paste0("Their card reads: ", specific_action$Objective))
    location <- player_position
    
    if(specific_action$Places != "")
    {
      #removed problem cards here
      
      if(specific_action$Places %in% problem_cards)
      {
        #print(specific_action$Places)
        location <- action_card_movement(1, player_position, specific_action$Places)
      }
      
      else
      {
        #print(specific_action$Places)
        location <- which(spaces %in% specific_action$Places)
      }
    }
  }
   
  if(player_position %in% community_chest_locations)
  {
    community_cards <- action_cards %>% filter(Card.Type %in% "Community")
    rand_num <- sample(1:16, 1, replace = TRUE)
    specific_action <- community_cards[rand_num,]
    print(paste0("Player", playerID, " lands on Community Chest and draws a Community Chest card."))
    print(paste0("Their card reads: ", specific_action$Objective))
    location <- player_position
    
    if(specific_action$Places != "")
    {
      #removed problem cards here
      
      if(specific_action$Places %in% problem_cards)
      {
        #print(specific_action$Places)
        location <- action_card_movement(1, player_position, specific_action$Places)
      }
      
      else
      {
        #print(specific_action$Places)
        location <- which(spaces %in% specific_action$Places)
      }
    }
  }
  
  if((player_position %in% chance_locations) == FALSE && (player_position %in% community_chest_locations) == FALSE)
  {
    location <- player_position
  }
  
  return(location)
}

```


